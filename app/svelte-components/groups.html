<div class="component component-group has-minor-navigation view-{{ view }}">
  <nav class="minor-navigation items-2">
    <h1>TO DO</h1>

    <ul class="cf">
      <li><a href="#/featured" on:click="eventSet(event, { view: 'featured' })"
        class="featured {{ view === 'featured' ? 'active' : '' }}">Featured</a></li>
      <li><a href="#/map" on:click="eventSet(event, { view: 'map' })"
        class="distance {{ view === 'map' ? 'active' : '' }}">Near Me</a></li>
    </ul>
  </nav>

  {{#if view === 'featured'}}
    <ul class="groups-items">
      {{#each allListsItems as i @airtableId}}
        <li>
          <a href="{{ data.basePath }}/{{ i.filename }}">
            {{#if i.mainImage && i.mainImage[0] }}
              <img src="{{ i.mainImage[0].url }}" alt="Main image for '{{ i.title }}'">
            {{/if}}
            <span>{{ i.title || i.name }}</span>
          </a>
        </li>
      {{/each}}
    </ul>
  {{/if}}

  {{#if view === 'map'}}
    <div class="map-items-container">
      <div class="map-wrapper">
        <div class="map" ref:itemsMap></div>
      </div>

      <div class="map-items">
        {{#each allItems as i @airtableId}}
          <Item data="{{ i }}" utils="{{ utils }}" store="{{ store }}"
            display="map" view="{{ view }}" />
        {{/each}}
      </div>
    </div>
  {{/if}}
</div>

<script>
import Item from './items.html';
import mapStyles from '../map-styles';

export default {
  components: {
    Item
  },

  oncreate: function() {
    // Make all items
    this.observe('data', n => {
      if (n.items || n.lists) {
        this.set({ allItems: this.allItems(this.get('data')) });
      }
    });

    // React to view change.  Since we need to have access to the dom
    // for the map, we defer the observe
    this.observe(
      'view',
      (n, o) => {
        if (n && n !== o) {
          if (n === 'featured') {
            this.showFeatured();
          } else if (n === 'map') {
            this.showMap();
          }
        }
      },
      { init: false, defer: true }
    );
  },

  methods: {
    // Proxy around set to be able to prevent default
    eventSet: function(e, properties) {
      if (e && e.preventDefault) {
        e.preventDefault();
      }

      this.set(properties);
    },

    showFeatured: function() {
      this.set({ view: 'featured' });
    },

    showMap: function() {
      this.set({ view: 'map' });

      if (this.get('isBrowser') && window.google) {
        this.drawMap();
        this.observeItems();
      }
    },

    // Observe the items as the scroll
    observeItems() {
      let threshold = 0.8;
      let items = this.get('allItems');
      let observer = new IntersectionObserver(
        (entries, observer) => {
          // We only want to highlight one element at a time, so
          // order by the top and which one is in view.
          let sorted = _.sortBy(entries, e => {
            return (
              (e.intersectionRatio >= threshold ? 1 : 10000) +
              e.boundingClientRect.y
            );
          });
          if (sorted[0].intersectionRatio >= threshold) {
            sorted[0].inView = true;
          }

          // Update views
          sorted.forEach(e => {
            let id = e.target.getAttribute('data-id');
            if (e.inView) {
              this.itemInView(id);
            } else {
              this.itemNotInView(id);
            }
          });
        },
        {
          root: document.querySelector('.map-items'),
          margin: '40%',
          threshold: [0, 0.5, 0.75, 0.85, 1]
        }
      );

      if (items && items.length) {
        for (let i of items) {
          let el = document.querySelector('[data-id="' + i.id + '"]');
          observer.observe(el);
        }
      }
    },

    // Item in view
    itemInView(item) {
      let items = this.get('allItems');

      // Handle string ID
      if (_.isString(item)) {
        item = _.find(items, { id: item });
      }
      if (!item) {
        return;
      }

      item.inView = true;
      this.set({ allItems: items });

      this.__markers[item.id].setIcon({
        path: google.maps.SymbolPath.CIRCLE,
        scale: 10,
        fillColor: '#00F',
        fillOpacity: 0.8,
        strokeWeight: 1
      });

      // TODO: Handle user location as well
      let bounds = new window.google.maps.LatLngBounds();
      bounds.extend({
        lat: parseFloat(item.latitude),
        lng: parseFloat(item.longitude)
      });
      //this.__map.fitBounds(bounds);
      this.__map.setCenter(bounds.getCenter());
      this.__map.setZoom(14);
    },

    // Item not in view
    itemNotInView(item) {
      let items = this.get('allItems');

      // Handle string ID
      if (_.isString(item)) {
        item = _.find(items, { id: item });
      }
      if (!item) {
        return;
      }

      item.inView = false;
      this.set({ allItems: items });

      if (this.__markers[item.id]) {
        this.__markers[item.id].setIcon({
          path: google.maps.SymbolPath.CIRCLE,
          scale: 10,
          fillColor: '#0F0',
          fillOpacity: 0.8,
          strokeWeight: 1
        });
      }
    },

    // Draw google map
    drawMap: function() {
      // Twin cities
      let defaultCenter = {
        lat: 44.9629232,
        lng: -93.159196
      };
      let defaultZoom = 11;

      // Only draw map if needed
      if (!this.__map) {
        this.__map = new window.google.maps.Map(this.refs.itemsMap, {
          zoom: defaultZoom,
          center: defaultCenter,
          zoomControl: true,
          mapTypeControl: false,
          scaleControl: false,
          streetViewControl: false,
          rotateControl: false,
          fullscreenControl: false,
          styles: mapStyles
        });

        // Create markers if needed
        if (!this.__markers || !this.__markers.length) {
          this.__markersBound = new window.google.maps.LatLngBounds();
          this.__markers = {};

          this.get('allItems').forEach(i => {
            if (i.latitude && i.longitude) {
              let p = {
                lat: parseFloat(i.latitude),
                lng: parseFloat(i.longitude)
              };

              let infowindow = new window.google.maps.InfoWindow({
                content: i.name || i.title
                // maxWidth: 200
              });

              let marker = new window.google.maps.Marker({
                position: p,
                title: i.name || i.title
              });
              marker.addListener('click', function() {
                infowindow.open(this.__map, marker);
              });

              this.__markersBound.extend(p);
              this.__markers[i.id] = marker;
            }
          });
        }

        // Add markers to map
        for (let i in this.__markers) {
          this.__markers[i].setMap(this.__map);
        }

        // Show all markers
        this.__map.fitBounds(this.__markersBound);
      } else {
        window.google.maps.event.trigger(this.__map, 'resize');
      }
    },

    // All items (items in lists)
    allItems: function(data) {
      let o = [];
      if (data.lists) {
        data.lists.forEach(l => {
          if (l.items && l.items.length) {
            o = o.concat(l.items);
          }
        });
      }
      if (data.items) {
        o = o.concat(data.items);
      }

      return o;
    }
  },

  computed: {
    // Top level lists and items
    allListsItems: function(data) {
      let o = [];
      if (data.lists) {
        o = o.concat(data.lists);
      }
      if (data.items) {
        o = o.concat(data.items);
      }

      return o;
    }
  },

  data() {
    return {
      isBrowser: typeof window !== undefined,
      view: 'featured'
    };
  }
};
</script>
